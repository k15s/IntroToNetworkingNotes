# 2-0 Transport Intro
+ transport layer - service for communication between applications
+ TCP: reliable bidirectional bytestream

# 2-1 TCP service model
+ almost universally used since it provides reliable bidirectional bytestream
  service that almost all apps want
+ transport layer
    + app gives it bytes
    + TCP puts them in a TCP segment
    + gives segments to IP layer, which encapsulates that
    + gives IP datagram to link layer to make link container
+ 2 way communication channel
+ first A -> B then B -> A to form a connection
    + 3 way handshake
    + A to B with syn message, number with starting number for bytestream
    + B to A with synack message, number with starting number for bytestream in
      reverse direction
    + A to B with ack message
+ stream of bytes service, delivered in order by both ends working together
    + A puts bytes into TCP segment -> IP layer -> delivery
    + B extracts bytes to recreate bytestream for app delivery
    + think of the sent data as a structured array of bytes (numbered as well)
+ communication teardown/close connection
    + tell each other they're closing, then both ends can clean state
    + A sends Fin message
    + B sends (Data +) Ack
        + if B still has data it wants to send, it can also carry new data
    + B sends Fin message
    + A sends Ack, connection fully closed since both sides finished
+ reliability
    + acknowledgement message to let sender know data sent correctly
    + checksum in header detect corrupted data
    + sequence numbers - every header has sequence header of first byte in
      specific segment
    + flow control prevents overrunning receiver
        + if sender is much faster, it can overwhelm receiver
        + receiver therefore tells sender how much room it has to accept data
+ congestion control to divide service around network
+ segment header (complicated because of reliability)
    + destination port, like port 80
    + source port, for where destination should send data back to
    + sequence number: position of first byte in data field
    + acknowledgement sequence number: say which byte to expect next
        + if 751, then received [1, 750]
    + checksum: calculated over header and data for error detection
    + header length field: number of option fields can be derived
    + flags
        + ack, synchronized, fin, push
+ unique ID of TCP connection generated by all fields below
    + IP source
    + IP destination
    + IP protocol ID = "TCP"
    + source port (incremented one by one to maintain uniqueness)
    + destination port
+ Sequence Numbers for bytes
    + sender gives sequence number of starting byte in current segment, so it's
      usually offset from starting byte/ISN (initial sequence number)
    + receiver responds with Ack sequence number = next expected byte

# 2-2 UDP service model
+ User Datagram Protocol: used by apps that don't need reliable delivery
+ very simple: takes app data, creates UDP datagram, hands to network layer
    + encapsulated inside IP datagram
    + source port
    + destination port: where to deliver to at end point
    + length field: length of entire datagram
    + checksum
+ connectionless datagram service: no connection established since none is
  needed, all info self contained in datagram
+ unreliable: no acks, no detection of missing datagrams, no flow control

# 2-3 ICMP service model
+ Internet Control message protocol to debug network layer
    + communicates network layer information between hosts
    + reports error conditions to help diagnose problems
+ runs above network layer -> transport layer protocol
+ self-contained message reporting error - unreliable, no retries, simply sends
  back a digest
    + borrows header and part of data from original IP datagram
    + also attaches error type and code
    + sends it back to source

# 2-4 End-to-End-Principle
+ correctness and "strong"
+ network could possibly do all sorts of things to help, but that's all it can
  do
    + network can help you, but you can't depend on it
    + end to end has to do the work, can't rely on the network
+ file transfer example - want file to pass through multiple machines
  uncorrupted
    + network provided error detection on links, assumed that this could detect
      all errors
    + but...say a computer has buggy memory and flips bits
    + machine would corrupt it, then forward it, but the error checking on the
      link would think it's fine - designed for errors in transmission not
      storage
    + only an end to end check will work - source should send error detection
      information
+ link reliability example
    + while the network can't do all the work, it can provide enhancement
    + immediate feedback makes TCP extremely reliable
+ if you want it done correctly, at some point you have to rely on end to end
  work
+ strong end to end principle: no enhancements, save 100% for end to end work

# 2-5 Error Detection: 3 schemes
+ error detection
    + payload of data, calculate error detection bits over this data 
    + 
+ IP Checksum
    + TCP and IP
    + add up values in the packet, very fast
    + not very robust, weak guarantees and easily fooled
        + single bit error detecting
    + Algorithm
        + set checksum field to 0
        + add all 16-bit words in packet
        + add carry bits back in
        + flip bits unless 0xffff
        + to check, sum whole packet, including checksum, should be 0xffff
+ CRC: cyclic redundancy code
    + much more expensive than checksum, also robust
    + computes remainder of polynomial
    + link layers use CRC's
    + protects agaisnt any burst <= c bits long, odd length errors, 2 bit errors
    + link layer heavily lifting
    + Algorithm
        + distill n bits of data into c bits, c << n
        + polynomial long division
            + M = 10011101 = x^7 + x^4 + x^3 + x^2 + 1
            + x^(index of 1)
        + generator polynomial (depends on what you pick...)
            + 0x8005 = 1000000000000101 = x^15 + x^2 + 1 + x^16 (pad at front so
              exponent is max + 1)
        + CRC = M / G, remainder is CRC which is appended
        + 
+ MAC: message authentication code
    + combines packet data with secret authentication value
    + robust against malicious modifications but not good at catching errors
    + any 2 messages have a 2^(-c) chance of having same code
    + bad since TONS of packets are sent around
    + apply existing MAC algorithm to message M and secret

Errors
    + MAC cannot guarantee anything, but still can detect errors
    + single bit error
        + 8 bit checksum, 16 bit checksum, 8 bit CRC, 16 bit CRC
    + run of 2 bit errors
        + 8 bit CRC, 16 bit CRC
    + run of 9 bit errors
        + 16 bit CRC since 16 > 9
    + two bit errors 100 bits part
        + no way...

+ Algorithms guarantee very little, but high probability is still good!
+ layering protections also helps

# 2-7 Reliable Communications - Stop and Wait
+ basic problem
    + sender can send data faster than receiver can process it
+ don't send more packets than receiver can process
    + receiver gives sender feedback
    + 2 basic approaches
        + stop and wait
        + sliding window
+ stop and wait
    + at most one packet in flight at any time
    + sender sends one packet
    + receiver sends ack packet when it receives data
    + on receiving ack, sender sends new data
    + on timeout, hasn't heard ack signal, sender resends current data
+ Executions
    + No loss
        + sender sends data to receiver, times out in wait for ack state
        + receiver responds with ack
    + data loss
        + sender sends data, doesn't get to receiver
        + sender is still timed out in ack state
        + sender re-sends data
        + receiver responds with ack
    + ack loss
        + sender sends data to receiver, times out in wait for ack state
        + receiver responds with ack, gets lost
        + sender re-sends data, times out in wait for ack state
        + receiver responds with ack
    + ack delay (failure)
        + sender sends data to receiver, times out in wait for ack state
        + receiver sends ACK, but it's delayed past timeout length
        + sender re-sends data before ack arrives
        + ack arrives
        + sender sends another data packet
        + receiver sends ACK
            + sender doesn't know if this ACK is for re-transmissioned data
              or new data packet
+ Duplicates problem
    + how do you know when ACK's are from re-transmissions or new data
    + use 1-bit counter in data and acknowledgements
        + alternate between data 0 - ack 0 and data 1 - ack 1
    + counter only works if assuming delay doesn't last more than a timeout, and
      no duplicate packets

# 2-8 Reliable Communications - Sliding Window
+ stop and wait is inefficient
+ sliding window
    + allows up to n packets in flight, as opposed to just 1 like a stop and
      wait
    + if n is at the optimal value, the pipe can be kept full/maximize transfer
      rate
+ say n = 3
    + sender sends 3 packets to receiver in sequence, d0 d1 d2
    + receiver sends 3 acks, ack0 ack1 ack2
    + when a0 arrives, sender sends d3
    + when a1 arrives, sender sends d4
    + when a2 arrives, sender sends d5
+ every segment has a sequence number (SeqNo)
+ vars of sender
    + sending window size (SWS)
    + last acknowledgement received (LAR)
    + last segment sent (LSS)
+ maintain invariant (LSS - LAR) <= SWS
    + if it has received packet number n, sender cannot send packet n + sws
+ advance LAR on new ack
+ stalling problem
    + sent packet drops, while the rest of the data in window sent successfully
    + window can't slide until ack received for that first, dropped data
+ sliding window receiver
    + receive window size (RWS)
    + last acceptable segment (LAS): last segment it will receive and not drop,
      receiving a segment past this value means something is wrong
    + last segment received (LSR)
+ maintain invariant (LAS - LSR) <= RWS
+ if received packet < LAS, send cumulative ACK, largest value possible, if one
  packet dropped but the next is received, it will still respond with packet
  value prior to the one dropped
    + RCP's ack value is (n + 1), NEXT expected data
+ RWS and SWS >= 1
+ RWS <= SWS, otherwise it's a waste
+ sender can only send data up to LAR + window

# 2-9 Reliable Communications - Retransmission Strategies
+ have a window of packets in flight
    + go back N: one loss will lead to entire window retransmitting, pessimistic
    + selective repeat: one loss, only that packet retransmitting, optimistic
+ Go-back-N
    + window size = 4
    + packets 1, 2, 3, 4 sent -> 2 is lost
    + ack 1, won't send ack 2
    + retransmit timer goes off, protocl requires sender to retransmit entire
      window 2, 3, 4, 5
+ Selective Repeat
    + window size = 4
    + packets 1, 2, 3, 4 sent -> 2 is lost
    + ack 1, so 5 is sent
    + transmitter retransmits 2, and then 6, 7, 8, 9...
    + what if 2, 3, 4, 5 all lost?
        + can be slower for a burst of losses, retransmit time and timers make
          things more complicated
+ tradeoff between speed of recovery and how much data is sent 

#2-10 Reliable communications - TCP Header
+ source port
+ destination port
+ sequence number: from source of this packet -> destination, what is sequence
  number of data contained in this segment
+ acknowledgement number: from endpoint, next byte needed
    + sequence number 4000
    + to acknowledge received UP TO byte 5000, so received up to last byte + 1
    + 4000 to 4999 in segment
+ checksum: computed over psuedoheader (header + IP header) and data
    + 
+ window: how much received buffer space sender has
    + 20,000 so no more than 20,000 outstanding bytes in that direction
+ Reserved U,A,P,R,S,F: control bits
    + U: urgent bit
    + P: push bit, please push this data to the receiving application
    + A: ack bit, 1 if acknowledgement field is valid, so set to 1 for almost
      every segment except first one
    + S: syn bit, set up connection - here's my starting sequence number, please
      synchronize to it
    + R: reset bit, need to reset this connection - something has gone wrong
    + F: fin bit, tearing down connection, no more data to send
+ offset field: possible for TCP to have options, so it says where data begins
  after the options

#2-11 Reliable Communications - setup and teardown
+ want to communicate reliably
    + state is good, but how do we set it up and then clean it up?
    + the state takes up RAM, when can we garbage collect it
    + buffers/memory/data structs, port...
+ 4 parts of header are used for setup
    + sequence number, acknowledge number, ack bit, syn bit
+ 3-way handshake
    + active opener initiates, passive waits
    + active opener sends TCP segment with syn bit set, so let's synchronize,
      and give first sequence number
        + don't just start from 0 -> more secure options if you can randomize
          starting sequence number
        + also avoids confusing separate sequences with each other!
    + passive responds with syn, starting sequence number + 1, and set ack bit
        + recall the sequence number response is based of last byte + 1/first
          byte not received/first next to send
    + active responds
        + no syn needed, already synchronized
        + sends ack, sa + 1 (for response)
+ simultaneous open
    + both sides know each other's port numbers beforehand
    + both sides send syns at the same time
        + two syns pass each other in the network
    + each side responds/acks the other the moment corresponding syn arrives
    + this takes 4 messages rather than 3
+ teardown
    + uses sequence number, ack number, ack and FIN bits
    + FIN bit says the sender has no more data to send/end of stream from sender
        + caused by close() or shutdown()
    + bidirectional, so terminate when BOTH Sides have nothing left to send
    + exchange (active closes first)
        + active sends fin, ack, sequence number a
        + passive sends ack with sequence number a + 1
        + passive can still send more data right now!
        + passive wants to close, sends fin, sequence number, and ack Sa+1
        + active sends ack
    + cleaning up safely
        + when can we actually re-use the ports?
        + what if the final ack is lost in the network?
            + sent fin, receive fin, ack it, can't immediately tear it down
            + if ack gets lost, other side won't hear it
        + what if the same port pair is re-used immediately?
            + might corrupt data if sequence numbers overlap
        + TIMEWAIT solution
            + if I send the first fin, once the connection is torn down, I have
              to wait around for a bit
            + keep socket around for 2 maximum segment lifetimes 
            + segments might still be living in network...so wait
            + this can cause server problems
                + OS has too many sockets waiting, this slows performance
